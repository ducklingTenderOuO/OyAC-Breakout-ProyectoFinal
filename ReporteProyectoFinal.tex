\documentclass[12pt, letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[spanish]{babel}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{hyperref} % Para enlaces y referencias cruzadas

\geometry{
    left=2.5cm,
    right=2.5cm,
    top=2.5cm,
    bottom=2.5cm
}

% Configuración de colores para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\begin{titlepage}
    \centering
    
    % Marcadores de posición para las imágenes. 
    % Asegúrate de que los archivos existan en la misma carpeta o comenta estas líneas si no tienes las imágenes.
    \includegraphics[width=0.22\textwidth]{escudo-actualizado-2022.png} 
    \hspace{1cm}
    \includegraphics[width=0.28\textwidth]{1593484343817.jpg} 
    
    \vspace{1cm}
    
    \Large
    UNIVERSIDAD AUTÓNOMA DE BAJA CALIFORNIA\\
    FACULTAD DE INGENIERÍA CAMPUS MEXICALI\\
    INGENIERÍA EN COMPUTACIÓN
    
    \vspace{1.8cm}
    
    \Large
    \textbf{Reporte: Proyecto Final}\\
    \textbf{Breakout}\\
    \vspace{1cm}
    Organización y Arquitectura de Computadoras\\
    Omar Muñoz Urias
    
    \vspace{1.8cm}

    \Large
    Moya Monreal Erick Anselmo - 01110604\\
    Jimenez Barrera Astrid Yamilet - 01182660\\
    \vspace{1.5cm}
    Fecha de entrega: 04 de Diciembre del 2025
    \vspace{.8cm}
    \normalsize\\
    Ciclo escolar 2025-2\\
    \today
    
\end{titlepage}

% Índice (Opcional, puedes comentarlo si no lo necesitas)
\tableofcontents
\newpage

\section{Introducción}

El presente proyecto fue desarrollado como parte final del curso de Organización y Arquitectura de Computadoras. Consiste en la implementación de un videojuego completo tipo "Breakout", el cual está escrito utilizando una combinación de lenguaje C con la librería SDL3 para la gestión gráfica, y ensamblador MASM x86 inline para la programación de la lógica interna del juego.

La arquitectura del proyecto se dividió en dos capas principales:
\begin{itemize}
    \item \textbf{Capa de Alto Nivel (C):} Responsable de inicializar la ventana de juego, renderizar los gráficos en pantalla, capturar eventos del teclado y gestionar el bucle principal del juego.
    \item \textbf{Capa de Bajo Nivel (Ensamblador):} Responsable de la lógica central del juego. Aquí se programó el cálculo del movimiento de la pelota, la detección de colisiones, y el manejo directo de estructuras de datos en memoria para gestionar los puntajes.
\end{itemize}

El objetivo general de la práctica fue demostrar la viabilidad de integrar lenguajes de programación de alto y bajo nivel para crear un sistema eficiente y funcional. Adicionalmente, se buscó aplicar de manera práctica los conocimientos adquiridos durante el semestre, tales como:

\begin{itemize}
    \item El uso de saltos condicionales (\texttt{JMP}, \texttt{JE}, \texttt{JNE}, \texttt{JG}) y ciclos para controlar el flujo de ejecución directamente a nivel de procesador.
    \item El manejo directo de la memoria RAM mediante direccionamiento indirecto para controlar el arreglo de ladrillos y sus propiedades sin abstracciones del lenguaje de alto nivel.
    \item La implementación del algoritmo de ordenamiento burbuja completamente en ensamblador para gestionar la tabla de mejores puntuaciones.
    \item La manipulación de registros del procesador (EAX, EBX, ECX, EDX, ESI, EDI) para realizar operaciones aritméticas y lógicas de manera eficiente.
\end{itemize}

Finalmente, este proyecto permite visualizar de manera práctica cómo las instrucciones básicas del procesador (operaciones aritméticas, lógicas y de control de flujo) que pueden ser implementadas en ensamblador, interactúan para producir un entorno gráfico interactivo en tiempo real.

\section{Problemática y Justificación}

La problemática central que motiva este proyecto radica en el cumplimiento de los requerimientos estrictos establecidos para el proyecto final del curso de Organización y Arquitectura de Computadoras. El desafío principal consistió en idear y desarrollar una aplicación que lograra la convergencia entre un lenguaje de alto nivel y el lenguaje ensamblador. Para la capa de alto nivel, se tomó la decisión de utilizar el lenguaje C, debido a la experiencia previa y práctica que se tiene con su sintaxis.

Sin embargo, dado que las especificaciones del proyecto prohibían explícitamente el uso de la terminal para la interfaz de usuario y exigían un entorno gráfico, fue necesario implementar la biblioteca externa SDL3. La integración de esta herramienta representó un reto técnico considerable durante la etapa de configuración inicial; una vez superado este obstáculo, la problemática se trasladó a la correcta codificación de la lógica interna para asegurar que ambos lenguajes operaran en conjunto.

La justificación para resolver esta problemática es primordialmente académica: completar el proyecto es el requisito indispensable para acreditar la materia. Más allá de la calificación, la realización de este videojuego sirve como el medio para demostrar tangiblemente la adquisición de los conocimientos impartidos durante el semestre, probando que se tiene la capacidad de manipular manualmente los registros del procesador, controlar el flujo del programa y gestionar la memoria de manera eficiente en un entorno real.

\section{Objetivos de la Práctica}

\subsection{Objetivo General}
Diseñar e implementar una aplicación de software híbrida que integre un lenguaje de alto nivel con rutinas de bajo nivel, con el propósito de demostrar la aplicación práctica de los conocimientos adquiridos en el curso de Organización y Arquitectura de Computadoras. El proyecto busca cumplir con los requerimientos de evaluación mediante la creación de un entorno gráfico interactivo donde la lógica crítica sea gestionada directamente a través de instrucciones de ensamblador.

\subsection{Objetivos Específicos}
\begin{itemize}
    \item \textbf{Integración de lenguajes:} Establecer una comunicación eficiente entre el lenguaje C (encargado de la gestión de recursos y la interfaz gráfica mediante SDL3) y el lenguaje ensamblador x86 (encargado del procesamiento lógico), demostrando la interoperabilidad entre ambos niveles de abstracción.
    
    \item \textbf{Aplicación de algoritmos de ordenamiento:} Implementar manualmente el algoritmo de ordenamiento burbuja (\textit{Bubble Sort}) utilizando instrucciones de ensamblador para gestionar y organizar estructuras de datos en memoria, cumpliendo con el requisito de manipulación de algoritmos clásicos a bajo nivel.
    
    \item \textbf{Manipular memoria y estructuras de datos:} Utilizar direccionamiento indirecto y cálculo de desplazamientos (\textit{offsets}) en ensamblador para acceder y modificar arreglos de estructuras (\textit{structs}) en la memoria RAM, específicamente para la carga de niveles y propiedades de los ladrillos.
    
    \item \textbf{Controlar el flujo de ejecución:} Aplicar instrucciones de salto condicional (\texttt{JE}, \texttt{JNE}, \texttt{JMP}) y ciclos para implementar algoritmos lógicos complejos, como el ordenamiento de puntajes (Método de Burbuja) y la selección de dificultad.
    
\end{itemize}

\section{Marco Teórico}

Para comprender la implementación técnica de este proyecto, es necesario definir los conceptos fundamentales de la arquitectura de computadoras y las herramientas de software utilizadas. A continuación, se presentan las bases teóricas sobre la programación híbrida, el manejo de memoria y los algoritmos empleados.

\subsection{Librería SDL (Simple DirectMedia Layer)}
SDL es una biblioteca de desarrollo multiplataforma diseñada para proporcionar acceso de bajo nivel al hardware de audio, teclado, ratón, joystick y gráficos a través de OpenGL y Direct3D. 
\begin{itemize}
    \item \textbf{Función principal:} Actúa como una capa de abstracción que permite al programador escribir código en C para manejar ventanas y renderizado sin interactuar directamente con el driver de la tarjeta gráfica \cite{sdlwiki}.
    \item \textbf{Manejo de Eventos:} SDL utiliza una cola de eventos (\textit{event queue}) para capturar interacciones del usuario. Funciones como \texttt{SDL\_PollEvent} permiten extraer estos eventos (teclas presionadas, clics) para ser procesados dentro de un bucle infinito conocido como \textit{Game Loop}.
\end{itemize}

\subsection{Ensamblador Inline (\texttt{\_\_asm})}
El ensamblador en línea (\textit{Inline Assembly}) es una característica de los compiladores de C/C++ que permite incrustar instrucciones de lenguaje ensamblador directamente dentro del código fuente de alto nivel.
\begin{itemize}
    \item \textbf{Ventaja:} Según Irvine, esta técnica elimina la necesidad de enlazar archivos objeto externos y simplifica el paso de parámetros, ya que el bloque \texttt{\_\_asm} puede acceder a las variables declaradas en C por su nombre, sin necesidad de gestionar manualmente la pila de llamadas \cite{irvine}.
    \item \textbf{Uso:} Se utiliza para optimizar secciones críticas de código donde se requiere acceso directo a los registros del CPU o a banderas de estado específicas que no son accesibles desde C.
\end{itemize}

\subsection{Control de Flujo en Arquitectura x86}
A nivel de hardware, el procesador ejecuta instrucciones de manera secuencial a menos que se modifique el registro Puntero de Instrucción (EIP).
\begin{itemize}
    \item \textbf{Saltos Condicionales:} Son instrucciones que transfieren el control a una nueva dirección de memoria solo si se cumplen ciertas condiciones en el registro de banderas (\textit{EFLAGS}). Ejemplos comunes incluyen:
    \begin{itemize}
        \item \texttt{JE} (Jump if Equal): Salta si la bandera Zero Flag (ZF) es 1.
        \item \texttt{JG} (Jump if Greater): Salta si el resultado de una comparación anterior indica que el primer operando es mayor que el segundo (basado en banderas de signo y desbordamiento) \cite{stallings}.
    \end{itemize}
    \item \textbf{Ciclos:} En ensamblador, los bucles se construyen combinando etiquetas, comparaciones y saltos condicionales, o utilizando la instrucción \texttt{LOOP} que utiliza el registro \texttt{ECX} como contador automático.
\end{itemize}

\subsection{Direccionamiento de Memoria y Arreglos}
La memoria RAM se organiza linealmente. Para acceder a elementos dentro de una estructura de datos o un arreglo, se utiliza el \textbf{direccionamiento indirecto base más desplazamiento}.
\begin{itemize}
    \item \textbf{Principio:} Si un registro (como \texttt{ESI}) contiene la dirección base de un arreglo, se puede acceder al siguiente elemento sumando el tamaño del dato (offset). Por ejemplo, en un arreglo de enteros de 4 bytes, el segundo elemento se encuentra en \texttt{[ESI + 4]} \cite{tanenbaum}.
\end{itemize}

\subsection{Algoritmo de Ordenamiento de Burbuja}
Es un algoritmo de ordenamiento sencillo que funciona iterando repetidamente a través de la lista que se desea ordenar.
\begin{itemize}
    \item \textbf{Funcionamiento:} Compara elementos adyacentes y los intercambia (\textit{swap}) si están en el orden incorrecto. Este proceso se repite hasta que no se requieren más intercambios.
    \item \textbf{Complejidad:} Aunque no es el más eficiente para grandes volúmenes de datos ($O(n^2)$), su implementación a nivel de ensamblador es ideal para fines educativos porque ilustra claramente el uso de bucles anidados, comparaciones y movimiento de datos en memoria \cite{patterson}.
\end{itemize}

\subsection{Unidad de Punto Flotante (FPU x87)}
La FPU es un coprocesador dedicado a realizar operaciones con números reales (decimales). A diferencia de los registros generales (EAX, EBX), la FPU utiliza una \textbf{pila de registros} de 80 bits (\texttt{ST0} a \texttt{ST7}).
\begin{itemize}
    \item \textbf{Instrucciones clave:}
    \begin{itemize}
        \item \texttt{FLD}: Carga un valor de memoria y lo empuja al tope de la pila (\texttt{ST0}).
        \item \texttt{FSTP}: Saca el valor del tope de la pila y lo guarda en memoria.
        \item \texttt{FCOMIP}: Compara el tope de la pila con otro valor y actualiza las banderas del CPU para permitir saltos condicionales \cite{irvine}.
    \end{itemize}
\end{itemize}

% -------------------------------------------------------------------------
% REFERENCIAS
% -------------------------------------------------------------------------
\begin{thebibliography}{9}

\bibitem{irvine}
Irvine, K. R. (2019). 
\textit{Assembly Language for x86 Processors} (8th ed.). 
Pearson Education. Capítulos 6, 9 y 12.

\bibitem{sdlwiki}
LibSDL.org. (2024). 
\textit{SDL3 API Reference Documentation}. 
Recuperado de https://wiki.libsdl.org/SDL3/

\bibitem{stallings}
Stallings, W. (2016). 
\textit{Computer Organization and Architecture: Designing for Performance} (10th ed.). 
Pearson.

\bibitem{tanenbaum}
Tanenbaum, A. S. (2013). 
\textit{Structured Computer Organization} (6th ed.). 
Pearson Prentice Hall.

\bibitem{patterson}
Patterson, D. A., \& Hennessy, J. L. (2014). 
\textit{Computer Organization and Design} (5th ed.). 
Morgan Kaufmann.

\end{thebibliography}

\end{document}